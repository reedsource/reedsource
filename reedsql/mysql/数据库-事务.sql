-- 数据库事务管理
-- 什么是事务?
-- 把多个相关的DML操作捆绑成一个整体,要么全都成功,要么全都失败!

-- MySql事务管理方式: 默认的是自动提交
-- MySql认为每个DML语句都会有一个单独的事务,每执行一个DML语句,都会引起一个事务.DML语句执行结束之后,MySql会自动用提交的方式来结束事务
-- 提交之后,对数据库的修改被永久的保存,所有的事务都可以查询到这些修改!
-- 会话:客户端和服务器之间一个连续不断的交互过程!每个会话中有不同的事务
SELECT *
FROM 部门表;
INSERT INTO 部门表
VALUES (50, "", "");
DELETE
FROM 部门表
WHERE 部门编号 > 40;

-- 我们要关闭MySql数据库默认的自动提交方式,由我们自己来控制事务的开始于结束
-- 1. 关闭事务自动提交有两种方式
--  (1).执行语句 start transaction; -- 关闭数据库的自动提交方式
--  (2).执行语句 set autocommit = off;  -- 关闭数据库的自动提交方式
-- 2.当我们关闭自动提交之后,我们执行的第一个DML语句会引起一个事务
--   在事务没有结束之前,无论我们执行多少个DML语句,这些DML语句都是率属于同一个事务的
--   在事务中对数据库的修改被保存在事务的内存中,只有当前事务可以查询到这些修改!
-- 3.结束事务的方式有两种
--   (1)提交结束事务:对数据库的修改被保存到数据库中,所有的事务都可以查询到这些修改
--   (2)回滚结束事务:事务中对数据库的修改被统统的放弃,数据库恢复到事务开始之前的状态


-- ======================================================================================================================
-- 关闭自动提交的第一种方式:
-- 执行语句 start transaction; -- 关闭数据库的自动提交方式
-- 注意:这种方式是关闭会话级别的自动提交,在新的会话中,又是默认的自动提交方式


-- ----------------------------------------------------------------------------------------------------------------------
-- 关闭自动提交之后,以提交的方式来结束事务
START TRANSACTION; -- 关闭自动提交

INSERT INTO 部门表
VALUES (50, "AA", "AA"); -- 第一个DML语句引起一个事务

INSERT INTO 部门表
VALUES (60, "AA", "AA");
INSERT INTO 部门表
VALUES (70, "AA", "AA");
INSERT INTO 部门表
VALUES (80, "AA", "AA");
UPDATE 部门表
SET 部门名称 = "销售部"
WHERE 部门编号 = 50;

-- 在事务没有结束前,上面的所有的DML语句都是率属于一个事务的,事务中对对数据库的修改被保存在事务的内容中
-- 只有当前事务可以查询到这些修改
SELECT *
FROM 部门表;

-- 用提交的方式结束事务,对数据库的修改被保存到数据库中,所有事务可以查询到这些修改
commit;

-- ----------------------------------------------------------------------------------------------------------------------

-- 关闭自动提交之后,以回滚的方式来结束事务
START TRANSACTION; -- 关闭自动提交

INSERT INTO 部门表
VALUES (50, "AA", "AA"); -- 第一个DML语句引起一个事务

INSERT INTO 部门表
VALUES (60, "AA", "AA");
INSERT INTO 部门表
VALUES (70, "AA", "AA");
INSERT INTO 部门表
VALUES (80, "AA", "AA");
UPDATE 部门表
SET 部门名称 = "销售部"
WHERE 部门编号 = 50;

-- 在事务没有结束前,上面的所有的DML语句都是率属于一个事务的,事务中对对数据库的修改被保存在事务的内容中
-- 只有当前事务可以查询到这些修改
SELECT *
FROM 部门表;

-- 用回滚的方式结束事务,对数据库的修改被统统的放弃,数据库恢复到事务开始之前的状态
ROLLBACK;



-- ======================================================================================================================
-- 关闭自动的提交的第二种方式
-- 执行语句 set autocommit = off /set session autocommit = off;  -- 关闭数据库的自动提交方式
-- 注意:这种方式是关闭会话级别的自动提交,在新的会话中,又是默认的自动提交方式

-- 关闭会话级别的自动提交
SET
AUTOCOMMIT = OFF;
SET SESSION AUTOCOMMIT = OFF;

-- 我们可以查询自动提交的状态
SHOW
VARIABLES LIKE '%COMMIT%';

-- 重新打开自动提交方式
SET SESSION AUTOCOMMIT = ON;


-- ======================================================================================================================
-- 事务具有隔离性:一个事务的执行并不会影响其他的事务
-- 通过事务的隔离性来管理数据的读并发问题,也就是多个事务同时修改相同的数据的问题!

-- 设置事务的隔离级别有两种范围
-- 1.设置会话级别的隔离级别,只对当前会话有效
-- 2.设置全局级别的隔离级别,对所有的会话都是有效的
--   注意:设置全局级别的隔离级别之后,必须要关闭会话,新的隔离级别在下一个会话中生效

-- 设置全局级别额隔离级别的相关的SQL语句
SET
GLOBAL TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; -- 设置全局级隔离级别为读未提交
SET
GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;   -- 设置全局级隔离级别为读已提交
SET
GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE  READ; -- 设置全局级隔离级别可重复读
SET
GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;     -- 设置全局级隔离级别串行化

-- 查询隔离级别的相关的SQL语句
SELECT @@GLOBAL.TX_ISOLATION;

-- ======================================================================================================================
-- 使用行级锁,也称为悲观锁

-- 关闭数据库的自动提交
-- 通过SELECT * FORM 员工表 WHERE 员工编号 = 7369 FOR UPDATE ;启动行级锁
-- 启动行级的目的是只有当前事务可以修改7369这条记录;但是其他的事务可以修改非7369的记录
-- 事务结束之后,行级锁被释放
-- 注意:启动行级锁的查询语句必须要用主键作为查询条件,启动的才是行级锁,否则依旧是表级锁!


-- 关闭自动提交
START TRANSACTION;

-- 引起一个事务,并且启动行级锁,锁住7369这条记录
SELECT *
FROM 员工表
WHERE 员工编号 = 7369 FOR
    UPDATE;

-- 注意:启动行级锁的查询语句必须要用主键作为查询条件,启动的才是行级锁,否则依旧是表级锁!
SELECT *
FROM 员工表
WHERE 员工姓名 = "赵一" FOR
    UPDATE;

-- 启动行级的目的是只有当前事务可以修改7369这条记录;
UPDATE 员工表
SET 月薪 = 2000
WHERE 员工编号 = 7369;

-- 事务结束之后,行级锁被释放
commit;